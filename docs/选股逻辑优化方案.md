# 选股逻辑优化方案

## 一、问题诊断

### 1. 当前问题
从2020-2026真实数据回测看：
- **基础策略亏损54.82%**（简单动量策略）
- 增强风控将亏损降至29.05%
- 说明选股逻辑是核心问题

### 2. 测试脚本的问题
`test_real_data_2020_2026.py` 使用的选股逻辑：
```python
# 仅用20日动量排序
df['momentum_20'] = df.groupby('ts_code')['close'].pct_change(20)
day_data = day_data.sort_values('momentum_20', ascending=False).head(50)
```

**问题**：
- ❌ 过于简单，容易追高
- ❌ 没有考虑估值、质量、流动性
- ❌ 没有行业分散
- ❌ 没有使用完整的StockSelector

---

## 二、优化方向

### 短期优化（P0）- 立即可做

#### 1. 改进测试脚本的选股逻辑

**方案A：多因子综合评分**
```python
# 动量因子（30%）
df['momentum_score'] = df['ret_20d'].rank(pct=True)

# 反转因子（20%）- 短期超跌反弹
df['reversal_score'] = -df['ret_5d'].rank(pct=True)

# 估值因子（20%）- 低估值
df['value_score'] = -df['pe_ttm'].rank(pct=True)

# 质量因子（20%）- 高ROE
df['quality_score'] = df['roe'].rank(pct=True)

# 流动性因子（10%）- 高成交额
df['liquidity_score'] = df['amount'].rank(pct=True)

# 综合评分
df['composite_score'] = (
    0.3 * df['momentum_score'] +
    0.2 * df['reversal_score'] +
    0.2 * df['value_score'] +
    0.2 * df['quality_score'] +
    0.1 * df['liquidity_score']
)
```

**方案B：趋势+价值混合**
```python
# 趋势强度（50%）
df['trend_strength'] = (
    df['ret_20d'] > 0 &  # 上涨趋势
    df['close'] > df['ma_20'] &  # 价格在均线上
    df['ma_20'] > df['ma_60']  # 均线多头排列
).astype(float)

# 价值评分（30%）
df['value_score'] = (
    (df['pe_ttm'] < df['pe_ttm'].quantile(0.5)) &  # 低估值
    (df['pb'] < df['pb'].quantile(0.5))
).astype(float)

# 质量评分（20%）
df['quality_score'] = (
    (df['roe'] > 0.1) &  # ROE > 10%
    (df['debt_to_assets'] < 0.6)  # 负债率 < 60%
).astype(float)

df['composite_score'] = (
    0.5 * df['trend_strength'] +
    0.3 * df['value_score'] +
    0.2 * df['quality_score']
)
```

#### 2. 使用完整的StockSelector

**集成现有模块**：
```python
from sage_core.stock_selection.stock_selector import StockSelector, SelectionConfig

# 配置
config = SelectionConfig(
    model_type="lgbm",  # 使用LightGBM
    label_horizons=(10, 20),  # 10日+20日收益
    label_weights=(0.4, 0.6),
    risk_adjusted=True,  # 风险调整
    label_neutralized=True,  # 行业中性化
    ic_filter_enabled=True,  # IC筛选
)

# 训练
selector = StockSelector(config)
selector.fit(train_df)

# 预测
signals = selector.select_top(test_df, top_n=50, trade_date=date)
```

#### 3. 添加过滤条件

**基础过滤**：
```python
# 价格过滤
df = df[df['close'] > 5.0]  # 价格 > 5元

# 流动性过滤
df = df[df['amount'] > 5000]  # 成交额 > 5000万

# 市值过滤
df = df[df['total_mv'] > 50]  # 市值 > 50亿

# 涨跌停过滤
df = df[abs(df['pct_chg']) < 9.5]  # 排除涨跌停

# ST过滤
df = df[~df['name'].str.contains('ST', na=False)]
```

**行业分散**：
```python
# 每个行业最多选5只
selected = []
for industry, group in day_data.groupby('industry'):
    top_in_industry = group.nlargest(5, 'composite_score')
    selected.append(top_in_industry)
df_selected = pd.concat(selected).nlargest(50, 'composite_score')
```

---

### 中期优化（P1）- 1-2周

#### 1. 因子挖掘与测试

**新增因子**：
- **技术因子**：MACD、布林带、KDJ
- **量价因子**：量价背离、大单净流入
- **情绪因子**：换手率异动、振幅
- **基本面因子**：营收增速、现金流

**因子测试框架**：
```python
def test_factor_ic(df, factor_col, forward_return_col='ret_20d'):
    """测试因子IC"""
    ic_by_date = df.groupby('trade_date').apply(
        lambda x: x[factor_col].corr(x[forward_return_col], method='spearman')
    )
    return {
        'mean_ic': ic_by_date.mean(),
        'ic_ir': ic_by_date.mean() / ic_by_date.std(),
        'hit_rate': (ic_by_date > 0).mean(),
    }
```

#### 2. 市场环境识别

**牛熊市判断**：
```python
def identify_market_regime(df, index_code='000300.SH'):
    """识别市场环境"""
    index_data = df[df['ts_code'] == index_code]

    # 趋势判断
    ma_20 = index_data['close'].rolling(20).mean()
    ma_60 = index_data['close'].rolling(60).mean()

    if ma_20.iloc[-1] > ma_60.iloc[-1] * 1.05:
        return 'bull'  # 牛市
    elif ma_20.iloc[-1] < ma_60.iloc[-1] * 0.95:
        return 'bear'  # 熊市
    else:
        return 'neutral'  # 震荡市
```

**动态调整策略**：
```python
if market_regime == 'bull':
    # 牛市：激进动量
    weights = {'momentum': 0.6, 'value': 0.2, 'quality': 0.2}
elif market_regime == 'bear':
    # 熊市：防御价值
    weights = {'momentum': 0.2, 'value': 0.4, 'quality': 0.4}
else:
    # 震荡市：均衡
    weights = {'momentum': 0.4, 'value': 0.3, 'quality': 0.3}
```

#### 3. 行业轮动

**行业景气度评分**：
```python
def score_industry_momentum(df):
    """行业动量评分"""
    industry_ret = df.groupby(['trade_date', 'industry'])['ret_20d'].mean()
    industry_score = industry_ret.groupby('trade_date').rank(pct=True)
    return industry_score

# 优先选择景气行业
df['industry_score'] = score_industry_momentum(df)
df['final_score'] = df['stock_score'] * (1 + 0.3 * df['industry_score'])
```

---

### 长期优化（P2）- 1个月+

#### 1. 机器学习模型优化

**特征工程**：
- 时序特征：滞后特征、滚动统计
- 交叉特征：因子交互项
- 行业特征：行业相对强度

**模型集成**：
```python
# 多模型融合
models = {
    'lgbm': LGBMRegressor(),
    'xgb': XGBRegressor(),
    'catboost': CatBoostRegressor(),
}

# Stacking
predictions = []
for name, model in models.items():
    model.fit(X_train, y_train)
    pred = model.predict(X_test)
    predictions.append(pred)

# 加权平均
final_pred = np.average(predictions, weights=[0.4, 0.3, 0.3], axis=0)
```

#### 2. 因子择时

**动态因子权重**：
```python
def dynamic_factor_weights(df, lookback=60):
    """根据近期IC动态调整因子权重"""
    recent_ic = {}
    for factor in factors:
        ic = df.tail(lookback).groupby('trade_date').apply(
            lambda x: x[factor].corr(x['ret_20d'])
        ).mean()
        recent_ic[factor] = max(ic, 0)  # 负IC设为0

    # 归一化
    total = sum(recent_ic.values())
    weights = {k: v/total for k, v in recent_ic.items()}
    return weights
```

#### 3. 组合优化

**均值-方差优化**：
```python
from scipy.optimize import minimize

def optimize_portfolio(expected_returns, cov_matrix, constraints):
    """马科维茨组合优化"""
    n = len(expected_returns)

    def objective(weights):
        return -weights @ expected_returns + 0.5 * weights @ cov_matrix @ weights

    constraints = [
        {'type': 'eq', 'fun': lambda w: np.sum(w) - 1},  # 权重和=1
        {'type': 'ineq', 'fun': lambda w: w},  # 权重>=0
    ]

    result = minimize(objective, x0=np.ones(n)/n, constraints=constraints)
    return result.x
```

---

## 三、立即行动计划

### Step 1: 改进测试脚本（今天）

修改 `test_real_data_2020_2026.py`：
1. 添加多因子评分
2. 添加基础过滤条件
3. 添加行业分散

### Step 2: 集成StockSelector（明天）

1. 准备完整特征数据（基本面+技术面）
2. 训练StockSelector模型
3. 对比简单策略 vs StockSelector

### Step 3: 因子测试（本周）

1. 测试各因子IC
2. 筛选有效因子
3. 优化因子权重

---

## 四、预期改善

### 保守估计
- 总收益率：-54% → -20%（改善34%）
- 最大回撤：-55% → -35%（改善20%）
- 夏普比率：-0.80 → -0.40（改善0.40）

### 乐观估计
- 总收益率：-54% → 0%（改善54%）
- 最大回撤：-55% → -25%（改善30%）
- 夏普比率：-0.80 → 0.00（改善0.80）

### 结合增强风控
如果选股改善到0%收益，增强风控再降低30%回撤：
- **最终目标**：年化收益5-10%，最大回撤<20%

---

## 五、参考资料

### 经典因子
- **动量因子**：Jegadeesh & Titman (1993)
- **价值因子**：Fama & French (1992)
- **质量因子**：Novy-Marx (2013)
- **低波因子**：Ang et al. (2006)

### A股特色因子
- **北向资金**：外资持股比例、净流入
- **融资融券**：融资买入额、融券余额
- **龙虎榜**：机构席位、游资席位
- **限售解禁**：解禁规模、解禁日期

---

**下一步**：要我帮你实现Step 1（改进测试脚本）吗？
